<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Promise构造函数的反模式</title>
    <url>/2021/04/10/Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>先从一个例子来看看Promise的常见的使用错误。</p>
<h4 id="Bad-Code"><a href="#Bad-Code" class="headerlink" title="Bad Code"></a>Bad Code</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad example! Spot 3 mistakes!</span></span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result) <span class="comment">// Forgot to return promise from inner chain + unnecessary nesting</span></span><br><span class="line">  .then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult));</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> doFourthThing());</span><br><span class="line"><span class="comment">// Forgot to terminate chain with a catch!</span></span><br></pre></td></tr></table></figure>

<h4 id="错误解析"><a href="#错误解析" class="headerlink" title="错误解析"></a>错误解析</h4><ul>
<li><p>The first mistake is to not chain things together properly. This happens when we create a new promise but forget to return it. As a consequence, the chain is broken, or rather, we have two independent chains racing. This means <code>doFourthThing()</code> won’t wait for  <code>doSomethingElse()</code> or <code>doThirdThing()</code> to finish, and will run in parallel with them, likely unintended. Separate chains also have separate error handling, leading to uncaught errors.（这样会导致多个独立的<code>Promise</code>链并行运行，而且不同的链需要不同的错误处理，这样会导致一些我们没有预期的错误。）</p>
</li>
<li><p>The second mistake is to nest unnecessarily, enabling the first mistake. Nesting also limits the scope of inner error handlers, which—if unintended—can lead to uncaught errors. A variant of this is the <a href="https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it">promise constructor anti-pattern</a>, which combines nesting with redundant use of the promise constructor to wrap code that already uses promises.（第二个错误是不必要的嵌套，会诱发第一个问题，而且也有错误处理问题，一个变体就是<code>promise 构造函数反模式</code>，这个我会在下面给出示例）</p>
</li>
<li><p>The third mistake is forgetting to terminate chains with <code>catch</code>. Unterminated promise chains lead to uncaught promise rejections in most browsers.（第三个错误就是没有用catch来终止<code>promise</code>链）</p>
</li>
</ul>
<h4 id="Good-Code"><a href="#Good-Code" class="headerlink" title="Good Code"></a>Good Code</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult))</span><br><span class="line">.then(<span class="function">() =&gt;</span> doFourthThing())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h4 id="反模式定义"><a href="#反模式定义" class="headerlink" title="反模式定义"></a>反模式定义</h4><p>下面来说说<code>Promise的构造函数反模式</code>,这是它的定义<code>which combines nesting with redundant use of the promise constructor to wrap code that already uses promises.</code></p>
<p>Example1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStuffDone</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">// using a promise constructor</span></span><br><span class="line">   	myPromiseFn(param)</span><br><span class="line">   	.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line"> 		resolve(val);</span><br><span class="line">   	&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    	reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Iview-admin中对反模式的使用"><a href="#Iview-admin中对反模式的使用" class="headerlink" title="Iview admin中对反模式的使用"></a>Iview admin中对反模式的使用</h4><p>另外再看一下<code>iview admin</code>中的应用（我只想说这个代码写的好迷呀🙄），违反了上面的注意事项，有两条不同的链，而且如果其中一个函数出错，那么肯定是没有得到处理，我觉得如果使用的化，最起码在两处加上<code>catch</code>语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">this</span>.handleLogin(&#123; userName, password &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getUserInfo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">            name: <span class="built_in">this</span>.$config.homeName</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//改成链式</span></span><br><span class="line"> <span class="built_in">this</span>.handleLogin(&#123; userName, password &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUserInfo()</span><br><span class="line"> 		&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          	<span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">            name: <span class="built_in">this</span>.$config.homeName</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;login error&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><code>Vuex</code>中的代码（代码里加了注释）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleLogin (&#123; commit &#125;, &#123; userName, password &#125;) &#123;</span><br><span class="line">      userName = userName.trim()</span><br><span class="line">    	<span class="comment">//这里用了Promise的构造函数反模式</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        login(&#123;</span><br><span class="line">          userName,</span><br><span class="line">          password</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> data = res.data</span><br><span class="line">          commit(<span class="string">&#x27;setToken&#x27;</span>, data.token)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo (&#123; state, commit &#125;) &#123;</span><br><span class="line">     <span class="comment">//这里用了Promise的构造函数反模式，这里注意最后TA使用了Try Catch来解决不同链的错误处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          getUserInfo(state.token).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = res.data</span><br><span class="line">         	....</span><br><span class="line">            commit(<span class="string">&#x27;setAccess&#x27;</span>, data.access)</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Quoting Esailija:</p>
<p>This is the most common anti-pattern. It is easy to fall into this when you don’t really understand promises and think of them as glorified event emitters or callback utility. Let’s recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</p>
<p>参考文章：</p>
<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a><br> <a href="https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it">https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it</a><br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>JS正则表达式迷你书知识点整理</title>
    <url>/2021/04/29/js%E6%AD%A3%E5%88%99/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>Regular expressions are patterns used to match character combinations in strings.</li>
</ul>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h5><ul>
<li>横向模糊匹配</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab&#123;2,5&#125;c/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;abc abbc abbbc abbbbc abbbbbc abbbbbbc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;abbc&quot;, &quot;abbbc&quot;, &quot;abbbbc&quot;, &quot;abbbbbc&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>纵向模糊匹配</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/a[123]b/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;a0b a1b a2b a3b a4b&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;a1b&quot;, &quot;a2b&quot;, &quot;a3b&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分支结构 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|nice/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;good idea, nice try.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;good&quot;, &quot;nice&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/good|goodbye/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;goodbye&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">//分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。</span></span><br></pre></td></tr></table></figure>

<h5 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h5><p> <code>^</code>   <code>$</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于位置的理解，我们可以理解成空字符 &quot;&quot;。</span></span><br><span class="line">^（脱字符）匹配开头，在多行匹配中匹配行开头。</span><br><span class="line">$（美元符号）匹配结尾，在多行匹配中匹配行结尾。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;hello&quot;</span>.replace(<span class="regexp">/^|$/g</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// =&gt; &quot;#hello#&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>\b</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。</span></span><br><span class="line"><span class="comment">// 对于位置的理解，我们可以理解成空字符 &quot;&quot;。(再来一遍)</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;[JS] Lesson_01.mp4&quot;</span>.replace(<span class="regexp">/\b/g</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// =&gt; &quot;[#JS#] #Lesson_01#.#mp4#&quot;</span></span><br></pre></td></tr></table></figure>

<p> <code>\B</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \B 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。</span></span><br><span class="line"><span class="comment">// 具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;[JS] Lesson_01.mp4&quot;</span>.replace(<span class="regexp">/\B/g</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// =&gt; &quot;#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>(?=)</code> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。</span></span><br><span class="line"><span class="comment">// 比如 (?=l)，表示 &quot;l&quot; 字符前面的位置，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;hello&quot;</span>.replace(<span class="regexp">/(?=l)/g</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// =&gt; &quot;he#l#lo&quot;</span></span><br></pre></td></tr></table></figure>

<p> <code>(?!)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (?!p) 就是 (?=p) 的反面意思</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">&quot;hello&quot;</span>.replace(<span class="regexp">/(?!l)/g</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// =&gt; &quot;#h#ell#o#&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="括号作用"><a href="#括号作用" class="headerlink" title="括号作用"></a>括号作用</h5><ul>
<li>分组与分组引用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(ab)+/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;ababa abbb ababab&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;abab&quot;, &quot;ab&quot;, &quot;ababab&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们知道 /a+/ 匹配连续出现的 &quot;a&quot;，而要匹配连续出现的 &quot;ab&quot; 时，需要使用 /(ab)+/。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;2017-06-12&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;12&quot;, index: 0, input: &quot;2017-06-12&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//match 返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的</span></span><br><span class="line"><span class="comment">//内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符 g，match</span></span><br><span class="line"><span class="comment">//返回的数组格式是不一样的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//match返回格式区别</span></span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017.06.27&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> regex1 = <span class="regexp">/\b(\d+)\b/</span>;</span><br><span class="line"><span class="keyword">var</span> regex2 = <span class="regexp">/\b(\d+)\b/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex1) );</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex2) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]</span></span><br><span class="line"><span class="comment">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有 g，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然</span></span><br><span class="line"><span class="comment">//后是整体匹配的第一个下标，最后是输入的目标字符串。</span></span><br><span class="line"><span class="comment">//有 g，返回的是所有匹配的内容。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = string.replace(regex, <span class="string">&quot;$2/$3/$1&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反向引用(很重要的应用)</span></span><br><span class="line"><span class="comment">//这里\1,保证了前面使用的和现在使用的是同一个符号。</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span>;</span><br><span class="line"><span class="keyword">var</span> string1 = <span class="string">&quot;2017-06-12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> string2 = <span class="string">&quot;2017/06/12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> string3 = <span class="string">&quot;2017.06.12&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> string4 = <span class="string">&quot;2016-06/12&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string1) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string2) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string3) ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string4) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>分支结构</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^I love (JavaScript|Regular Expression)$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">&quot;I love JavaScript&quot;</span>) );</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(<span class="string">&quot;I love Regular Expression&quot;</span>) );</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果去掉正则中的括号，即：</span></span><br><span class="line"><span class="comment">// /^I love JavaScript|Regular Expression$/，</span></span><br><span class="line"><span class="comment">// 匹配字符串是 &quot;I love JavaScript&quot; 和 &quot;Regular Expression&quot;，当然这不是我们想要的。</span></span><br></pre></td></tr></table></figure>

<h5 id="匹配原理"><a href="#匹配原理" class="headerlink" title="匹配原理"></a>匹配原理</h5><ul>
<li>回溯法，本质上就是深度优先搜索算法。其中退到之前的某一步这一过程，我们称为“回溯”。从上面的描述过程中 ，可以看出，路走不通时，就会发生“回溯”。即，尝试匹配失败时，接下来的一步通常就是回溯。使用场景可以参考我之前一篇的博客<code>全排列</code></li>
<li>贪婪量词回溯，最先开始全部匹配如果不成功，就一个个减少</li>
<li>惰性量词回溯，最先开始匹配最少情况，如果不成功，再递加。</li>
<li>分支结构回溯，第一个不合适，就换第二个，如此类推。</li>
</ul>
<p>最后来个书的作者形象总结：</p>
<ul>
<li><p>贪婪量词“试”的策略是：买衣服砍价。价钱太高了，便宜点，不行，再便宜点。 </p>
</li>
<li><p>惰性量词“试”的策略是：卖东西加价。给少了，再多给点行不，还有点少啊，再给点。</p>
</li>
<li><p>分支结构“试”的策略是：货比三家。这家不行，换一家吧，还不行，再换。</p>
</li>
</ul>
<h5 id="正则优先级"><a href="#正则优先级" class="headerlink" title="正则优先级"></a>正则优先级</h5><p>“这里稍微总结一下，竖杠的优先级最低，即最后运算。 只要知道这一点，就能读懂大部分正则。”</p>
<h5 id="正则表达式的构建"><a href="#正则表达式的构建" class="headerlink" title="正则表达式的构建"></a>正则表达式的构建</h5><ul>
<li><p>匹配预期的字符串 </p>
</li>
<li><p>不匹配非预期的字符串 </p>
</li>
<li><p>可读性和可维护性</p>
</li>
<li><p>效率</p>
</li>
</ul>
<h5 id="正则表达式编程"><a href="#正则表达式编程" class="headerlink" title="正则表达式编程"></a>正则表达式编程</h5><ul>
<li>验证 </li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\d/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( regex.test(string) );</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>提取</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017-06-26&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( string.match(regex) );</span><br><span class="line"><span class="comment">// =&gt;[&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>分割</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span>/<span class="number">06</span>/<span class="number">26</span></span><br><span class="line"><span class="number">2017.06</span><span class="number">.26</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">06</span>-<span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\D/</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;2017/06/26&quot;</span>.split(regex) );</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;2017.06.26&quot;</span>.split(regex) );</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;2017-06-26&quot;</span>.split(regex) );</span><br><span class="line"><span class="comment">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</span></span><br><span class="line"><span class="comment">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</span></span><br><span class="line"><span class="comment">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>替换</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">&quot;2017-06-26&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>( string.replace(<span class="regexp">/-/g</span>, <span class="string">&quot;/&quot;</span>) );</span><br><span class="line"><span class="built_in">console</span>.log( today );</span><br><span class="line"><span class="comment">// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>   “正则表达式是匹配模式，要么匹配字符，要么匹配位置”。</p>
<p>​    另外我觉得作者对于知识的定义很有意思， “什么叫知识，能指导我们实践的东西才叫知识。“。学习确实不能浅尝辄止，一定要落地实施。</p>
<p>   “说起正则表达式，我之所以会去详细地研究它，最初的动机是，当我分析前端常见的框架和库的源码时，发现一般被卡住的地方就是它。” 以上都是作者原话， 因为作者写这本书的动机是为了分析框架源码，个人远远没有到达这种阶段，而且日常开发中几乎没有使用过，所以这篇文章算是启蒙和参考书吧。</p>
]]></content>
      <categories>
        <category>正则</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>探秘Vue插槽</title>
    <url>/2021/07/30/vue%E6%8F%92%E6%A7%BD%E5%8F%98%E8%BF%81%E5%8F%B2/</url>
    <content><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>引用<code>v-slot</code>新语法</p>
<ul>
<li>新的<code>v-slot</code>命令联合了<code>slot</code>和<code>slot-scope</code>在一个单命令语法中。</li>
<li><code>v-slot</code>的简写，可以潜在地统一作用域插槽和普通插槽的使用。</li>
</ul>
<h3 id="基础样例"><a href="#基础样例" class="headerlink" title="基础样例"></a>基础样例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- default slot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- named slot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:one</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="改用v-slot的诱因"><a href="#改用v-slot的诱因" class="headerlink" title="改用v-slot的诱因"></a>改用<code>v-slot</code>的诱因</h3><p>当<code>Vue</code>团队第一次推出作用域插槽时，它的使用方法很冗余，因为它老是需要使用<code>&lt;template slot-scope&gt;</code>语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了作用域插槽的使用方法更加简洁，在2.5版本里，实现了<code>slot-scope</code>直接在元素插槽上使用，不需要再加上<code>template</code>这样没有意义的标签。（这样的改进确实是一个挺好的地方，但是很快他们就后悔了。。。。😂）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>这样也就代表了它在组件插槽上也同样适用。</strong>(噩梦开始的地方。。。)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面用法就导致一个问题，<code>slot-scope</code>并没有很好的体现是哪一个组件提供的作用域变量，虽然<code>slot-scope</code>放在了<code>bar</code>组件中，但是它的作用域变量实际上是由<code>foo</code>中默认插槽提供的。特别是在组件嵌套层级很深情况下，显得尤为恶心。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">slot-scope</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">baz</span> <span class="attr">slot-scope</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">&quot;baz&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">baz</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子显然不能立刻看出来那个组件提供了那些作用域变量。</p>
<p>一些人建议<code>vue</code>团队，应该允许使用<code>slot-scope</code>在组件自身上，以此来显示它默认插槽的作用域。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">slot-scope</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; foo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据上面的介绍，很明显这个功能实现不了，因为当具有插槽的组件嵌套时很容易导致歧义。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">foo</span> <span class="attr">slot-scope</span>=<span class="string">&quot;foo&quot;</span>&gt;</span> <span class="comment">&lt;!-- provided by parent or by foo? --&gt;</span></span><br><span class="line">    &#123;&#123; foo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这就是为啥，<code>vue</code>团队后悔在使用<code>slot-scope</code>时可以不使用<code>template</code>.</p>
<p><strong>那么问题就来了为什么不直接修改<code>slot-scope</code>语法，而是提出一个新的<code>vue</code>指令？</strong></p>
<ul>
<li>这是一个突破性的改变，不能在2.x版本发布。</li>
<li>即使在3.x版本中发布，然而这样会导致大量面向<code>Google</code>编程的程序员的困惑（因为Google出大量已经过时的资料🤣）。</li>
<li>在3.x版本中，计划统一<code>solt</code>类型，这样就没必要区分，作用域插槽，普通插槽啦。比如一个插槽可能会接受<code>props</code>也可能不会，但是这都是插槽，但是使用<code>slot</code>和<code>slot-scope</code>两个不同的属性，显得不必要。所以出现要一个统一的语法是大势所趋。</li>
</ul>
<h3 id="细节设计"><a href="#细节设计" class="headerlink" title="细节设计"></a>细节设计</h3><p>新的指令终于诞生了<code>v-slot</code></p>
<p>它可以被用在<code>template</code>插槽容器上，以表示传递给组件的插槽，其中插槽名称通过指令参数表示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;body&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>v-slot</code>作用域插槽,可以通过命令的属性值来接收<code>slot props</code>，同时<code>v-slot</code>的值和<code>slot-scope</code>有同样的运行方式，都支持解构语法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">      Message from header slot: &#123;&#123; msg &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-slot</code>可以直接被用于组件上，不需要任何参数来表明组件的默认插槽是作用域插槽，而且传向默认插槽的变量和没有做声明的插槽传入的变量是同样的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="新神VS旧神"><a href="#新神VS旧神" class="headerlink" title="新神VS旧神"></a>新神VS旧神</h3><p>对大多数作用域插槽的使用（单个默认插槽），仍然提供简洁的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;foo v-slot&#x3D;&quot;&#123; msg &#125;&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;foo&gt;</span><br></pre></td></tr></table></figure>

<p>新的语法提供更明确的作用域变量，和插槽的关系。再来看一下用<code>slot-scope</code>,<code>v-slot</code>深层嵌套的的比较。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">slot-scope</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">baz</span> <span class="attr">slot-scope</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">&quot;baz&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">baz</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">v-slot</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">v-slot</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">baz</span> <span class="attr">v-slot</span>=<span class="string">&quot;baz&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">baz</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认插槽中具有文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- old --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- new --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认插槽和元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- old --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- new --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>嵌套默认插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- old --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">slot-scope</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">baz</span> <span class="attr">slot-scope</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;baz&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">baz</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- new --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span> <span class="attr">v-slot</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">v-slot</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">baz</span> <span class="attr">v-slot</span>=<span class="string">&quot;baz&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; foo &#125;&#125; &#123;&#123; bar &#125;&#125; &#123;&#123; baz &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">baz</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具名插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- old --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;one&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    text slot: &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;two&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    element slot: &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- new --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:one</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    text slot: &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:two</span>=<span class="string">&quot;&#123; msg &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      element slot: &#123;&#123; msg &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>嵌套混合具名与默认插槽</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- old --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">slot</span>=<span class="string">&quot;one&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; one &#125;&#125; &#123;&#123; bar &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bar</span> <span class="attr">slot</span>=<span class="string">&quot;two&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot-scope</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; two &#125;&#125; &#123;&#123; bar &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- new --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:one</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bar</span> <span class="attr">v-slot</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; one &#125;&#125; &#123;&#123; bar &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:two</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bar</span> <span class="attr">v-slot</span>=<span class="string">&quot;bar&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; two &#125;&#125; &#123;&#123; bar &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>引入新的语法会带来混乱，并使生态系统中有关此主题的许多学习材料过时。新用户可能会在阅读现有教程后发现新语法而感到困惑。</li>
<li>默认的槽使用<code>v-lot=“&#123;msg&#125;”</code>并不能准确地传达这样的概念，即msg是作为<code>prop</code>传递给槽的。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong>，(只有<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">一种例外情况</a>) 。</p>
</li>
<li><p>当被提供的内容<em>只有</em>默认插槽时，组件的标签才可以被当作插槽的模板来使用。</p>
</li>
<li><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">&quot;otherSlotProps&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。</strong></p>
<p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;todo in filteredTodos&quot;</span><br><span class="line">    v-bind:key=&quot;todo.id&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    我们为每个 todo 准备了一个插槽，</span></span><br><span class="line"><span class="comment">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo&quot;</span> <span class="attr">v-bind:todo</span>=<span class="string">&quot;todo&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">&quot;todos&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><em>翻自：</em></p>
<p><a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md</a></p>
<p><a href="https://cn.vuejs.org/v2/guide/components-slots.html#ad">https://cn.vuejs.org/v2/guide/components-slots.html#ad</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue插槽</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>三栏布局</title>
    <url>/2021/04/09/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;		</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">120px</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><p>Flex布局的缺点是兼容性问题，如果IE10+还是没有问题的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h4><p>流式布局的缺点是，不能使content内容优先渲染。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/*display: flow-root;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="comment">/*overflow: hidden;*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><p>绝对定位布局，简单实用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25070186">https://zhuanlan.zhihu.com/p/25070186</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环详解</title>
    <url>/2021/08/13/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h1><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>可以试一下他的输出顺序。</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>

<p><em>在微软的Edge浏览器，和火狐40，Safari 8.0.8中<code>setTimeout</code>会比<code>promise1</code>和<code>promise2</code>先输出，出现这种情况真是奇了TML怪，因为Firefox39和Safari8.0.7一直都是正确的。</em></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>想要了解事件循环，需要先了解事件循环是如何处理宏任务，与微任务。</p>
<p>每一个线程有自己的事件循环机制。所以每一个<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Web_Workers_API/Using_web_workers"><code>web worker</code></a> 都是独立执行的，但是在同一个域名的窗口是同用一个事件循环，所以他们才可以同步通信。事件循环顺序执行队列任务。</p>
<h1 id="Nodejs事件循环"><a href="#Nodejs事件循环" class="headerlink" title="Nodejs事件循环"></a>Nodejs事件循环</h1><p>Nodejs的事件循环与浏览器的事件循环机制并不相同，Nodejs虽然使用<code>Chrome v8</code>作为JS解释引擎，但是异步控制的实现是在<code>libuv</code>库中。</p>
<p>来个栗子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">	<span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// start,</span></span><br><span class="line"><span class="comment">// end,</span></span><br><span class="line"><span class="comment">// promise3,</span></span><br><span class="line"><span class="comment">// timer1,</span></span><br><span class="line"><span class="comment">// timer2,</span></span><br><span class="line"><span class="comment">// promise1,</span></span><br><span class="line"><span class="comment">// promise2</span></span><br></pre></td></tr></table></figure>



<p>未完待续。。。</p>
<p>参考链接</p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p>
<p><a href="https://mp.weixin.qq.com/s/hE-tK_PbSYkMms8P9b2H7A">https://mp.weixin.qq.com/s/hE-tK_PbSYkMms8P9b2H7A</a></p>
<p><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/">https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/</a></p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2021/04/24/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="全排列1"><a href="#全排列1" class="headerlink" title="全排列1"></a>全排列1</h4><ul>
<li>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> res = [], path = [], used = [];</span><br><span class="line"></span><br><span class="line">    dfs(res, nums, <span class="number">0</span>, path, nums.length, used);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">res, nums, depth, path, len, used</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth == len)&#123;</span><br><span class="line">        res.push([...path]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">            path.push(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            dfs(res, nums, depth + <span class="number">1</span> , path, len, used)</span><br><span class="line">			</span><br><span class="line">            path.pop();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这种经典的算法题，最开始可能纠结于代码的执行顺序（可以在运行环境中打断点，一步一步执行，自己看看顺序），在我看来最重要的是算法结构，比如这里解决问题的思路就是通过<code>for</code>循环里加递归的结构，使用这个结构的特点是，执行递归后面的代码之后，会继续参加<code>for</code>循环，就是在这里实现了排列。</p>
<h4 id="全排列2"><a href="#全排列2" class="headerlink" title="全排列2"></a>全排列2</h4><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [res,path,used] = [[],[],[]];</span><br><span class="line"></span><br><span class="line">    nums.sort(<span class="function">(<span class="params">val1, val2</span>) =&gt;</span> val1 -val2);</span><br><span class="line"></span><br><span class="line">    dfs(res, path, used, nums, nums.length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">res, path, used, nums, len, depth</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth === len)&#123;</span><br><span class="line">        res.push([...path]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">        <span class="comment">//剪枝条件</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; !used[i-<span class="number">1</span>] &amp;&amp; nums[i] === nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">            path.push(nums[i])</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            dfs(res, path, used, nums, len, depth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            path.pop();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里多了一个剪枝条件，同时注意这里首先进行了排序处理。</p>
<p>参考链接：</p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>回流与重绘</title>
    <url>/2021/04/18/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h3 id="浏览器渲染的关键路径"><a href="#浏览器渲染的关键路径" class="headerlink" title="浏览器渲染的关键路径"></a>浏览器渲染的关键路径</h3><p>The critical rendering path includes the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">Document Object Model </a>(DOM), <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSS Object Model </a>(CSSOM), render tree and layout.</p>
<p><img src="/images/critical-rendering-path.png"></p>
<h3 id="关于渲染树"><a href="#关于渲染树" class="headerlink" title="关于渲染树"></a>关于渲染树</h3><p>The render tree only captures visible content. The head section (generally) doesn’t contain any visible information, and is therefore not included in the render tree. If there’s a display: none; set on an element, neither it, nor any of its descendants, are in the render tree.</p>
<p><img src="/images/render-tree-construction.png"></p>
<p>To construct the render tree, the browser roughly does the following:</p>
<ol>
<li>Starting at the root of the DOM tree, traverse each visible node.<ul>
<li>Some nodes are not visible (for example, script tags, meta tags, and so on), and are omitted since they are not reflected in the rendered output.</li>
<li>Some nodes are hidden via CSS and are also omitted from the render tree; for example, the span node—in the example above—is missing from the render tree because we have an explicit rule that sets the “display: none” property on it.</li>
</ul>
</li>
<li>For each visible node, find the appropriate matching CSSOM rules and apply them.</li>
<li>Emit visible nodes with content and their computed styles.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">note that visibility: hidden is different from display: none. </span><br><span class="line">The former makes the element invisible, but the element still occupies space in the layout (that is, it&#39;s rendered as an empty box), </span><br><span class="line">whereas the latter (display: none) removes the element entirely from the render tree such that the element is invisible and is not part of the layout.</span><br></pre></td></tr></table></figure>

<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>生成“布局”（layout）和”绘制”（paint）这两步，合称为”渲染”（render）。</p>
<p>聊到渲染我又想写写CSS的渲染阻塞，CSS不会阻塞Dom解析，但是会阻塞Dom渲染，阻塞JS的执行，有同学可能会有JS，CSS下载时间的疑惑，这就不得不提预加载扫描器（Preload Scanner）。</p>
<p>这是MDN的原话：</p>
<p>While the browser builds the DOM tree, this process occupies the main thread. As this happens, the <em>preload scanner</em> will parse through the content available and request high priority resources like CSS, JavaScript, and web fonts. Thanks to the preload scanner, we don’t have to wait until the parser finds a reference to an external resource to request it. It will retrieve resources in the background so that by the time the main HTML parser reaches requested assets, they may possibly already be in flight, or have been downloaded. The optimizations the preload scanner provides reduce blockages.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>In this example, while the main thread is parsing the HTML and CSS, the preload scanner will find the scripts and image, and start downloading them as well.  To ensure the script doesn’t block the process, add the <code>async</code> attribute, or the <code>defer</code> attribute if JavaScript parsing and execution order is not important.</p>
<p>Waiting to obtain CSS doesn’t block HTML parsing or downloading, but it does block JavaScript, because JavaScript is often used to query CSS properties’ impact on elements.</p>
<h3 id="布局与绘制定义"><a href="#布局与绘制定义" class="headerlink" title="布局与绘制定义"></a>布局与绘制定义</h3><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>Once the render tree is built, layout becomes possible. Layout is dependent on the size of screen. The layout step determines where and how the elements are positioned on the page, determining the width and height of each element, and where they are in relation to each other.</p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>The last step is painting the pixels to the screen. Once the render tree is created and layout occurs, the pixels can be painted to the screen. Onload, the entire screen is painted. After that, only impacted areas of the screen will be repainted, as browsers are optimized to repaint the minimum area required. Paint time depends on what kind of updates are being applied to the render tree.</p>
<h3 id="布局触发条件"><a href="#布局触发条件" class="headerlink" title="布局触发条件"></a>布局触发条件</h3><p> Any time the render tree is modified, such as by added nodes, altered content, or updated box model styles on a node, layout occurs.</p>
<h3 id="关于绘制"><a href="#关于绘制" class="headerlink" title="关于绘制"></a>关于绘制</h3><p>While painting is a very fast process, and therefore likely not the most impactful place to focus on in improving performance。</p>
<h3 id="浏览器优化机制"><a href="#浏览器优化机制" class="headerlink" title="浏览器优化机制"></a>浏览器优化机制</h3><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect</li>
<li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">https://gist.github.com/pauli…</a>点击预览</li>
</ul>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>
<h3 id="如何减少回流与重绘带来的性能损失"><a href="#如何减少回流与重绘带来的性能损失" class="headerlink" title="如何减少回流与重绘带来的性能损失"></a>如何减少回流与重绘带来的性能损失</h3><ul>
<li>先将元素设为<code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li>position属性为<code>absolute</code>或<code>fixed</code>的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li>
</ul>
<p>参考链接：</p>
<p><a href="https://segmentfault.com/a/1190000017329980">https://segmentfault.com/a/1190000017329980</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path</a></p>
<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>回流与重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>字节OpenDay总结</title>
    <url>/2021/04/12/%E5%AD%97%E8%8A%82OpenDay%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>​    大厂是在造轮子，而不是使用😶。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>首先他们介绍了南京字节的主要业务，数据平台。</li>
<li>进入Q&amp;A环节（主要聊了一些面试需要注意啥）。</li>
<li>吃吃工作餐。</li>
</ol>
<h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><ul>
<li>在简历中遵循STAR原则，结尾的Result中注意具体数据体现。</li>
<li>在面试时要从面试官的角度思考，要从一个点扩展到一个面。</li>
<li>如果在Github开源项目中有贡献最好。</li>
</ul>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><ul>
<li>在学习中要注意脑图的使用，组成自己的技术结构</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>我的秋招之路</title>
    <url>/2021/10/13/%E6%88%91%E7%9A%84%E7%A7%8B%E6%8B%9B%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><pre><code>- 美团优选
- 小红书
- 南京帆软
- 浙江大华
</code></pre>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>我 <strong>七月份</strong>开始投递公司，我觉得我的面试分<strong>三</strong>个阶段吧。 </p>
<ul>
<li><p><strong>第一阶段试探阶段</strong></p>
<ul>
<li>  第一家面了浙江大华提前批，两轮技术面加HR面，最后收获意向。然而到现在也没人联系我讨论工资的问题他🙄。这个阶段只是为了找找秋招的节奏，而且也写了很多公司的笔试。 </li>
</ul>
</li>
<li><h5 id="第二阶段自杀式投递大厂"><a href="#第二阶段自杀式投递大厂" class="headerlink" title="第二阶段自杀式投递大厂"></a>第二阶段自杀式投递大厂</h5><ul>
<li>  首先面了美团智慧交通平台，这是我第一次面互联网大厂，稍微有一点紧张，但面试官很nice，当时面了将近80分钟左右，但是一面挂了，目测是因为算法题写的太久。</li>
<li>   然后面了<strong>字节</strong>，字节一面的面试体验很好，面试官也挺年轻的，一面顺利通过了，字节二面碰到一些自己没有准备的东西就GG了</li>
<li>  再然后面了**<a href="">腾讯</a>TEG**，在视频面之前,来了两轮电话面，记得我当时接到电话面试的心情是很懵的一度以为不是<a href="">腾讯</a>，两轮电话面试中面试官都很nice，紧接着等来了视频一面，一面主要是做题，面试管没有问啥问题，可能是因为我之前已经两轮电话面了😶，在第二轮面试中，我明显感觉面试官气场不一样，死死被压制，以至于很多东西只能说了解过，但没有使用经历，菜狗留下没有技术的眼泪。</li>
<li>  同时，在大厂面试中也穿插着**<a href="">百度</a>一面<strong>和</strong><a href="">有赞</a>一面 ，**简单来说<a href="">百度</a>死于智力题，<a href="">有赞</a>败在<a href="">项目</a>经历。。 </li>
</ul>
</li>
<li><h5 id="第三阶段认清自己投递中厂"><a href="#第三阶段认清自己投递中厂" class="headerlink" title="第三阶段认清自己投递中厂"></a>第三阶段认清自己投递中厂</h5><ul>
<li> 小红书三面结束等待被捞中，9.30号收到邮件通知近期会有HR联系，10.26号已经OC。</li>
<li> <strong>南京帆软</strong>一面结束后进入offer审批中，已经收到意向。</li>
<li> <a href="">美团</a>优选被捞，但在第二轮视频面试中，觉得自己第二道场景题写的并不好，但还是在吃饭时收到HR面邀请，HR面结束后至今没有消息。</li>
<li> 通过<a href="">华为</a>运营商BG机试，专业面试，然后挂在主管面。。。 </li>
</ul>
</li>
</ul>
<h4 id="一点小建议"><a href="#一点小建议" class="headerlink" title="一点小建议"></a>一点小建议</h4><ul>
<li>众所周知互联网只有“夏招”和“冬招”，所以一定要抓住机会，提前投递，比如美团吧，提前批挂了，还有正式批来捞，如果晚了部门的HC就少了，被捞的概率就低了。</li>
</ul>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>求职</tag>
        <tag>校招</tag>
      </tags>
  </entry>
</search>
