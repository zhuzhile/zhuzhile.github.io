<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Promise构造函数的反模式</title>
    <url>/2021/04/10/Promise%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%8D%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>先从一个例子来看看Promise的常见的使用错误。</p>
<h4 id="Bad-Code"><a href="#Bad-Code" class="headerlink" title="Bad Code"></a>Bad Code</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad example! Spot 3 mistakes!</span></span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(result) <span class="comment">// Forgot to return promise from inner chain + unnecessary nesting</span></span><br><span class="line">  .then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult));</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> doFourthThing());</span><br><span class="line"><span class="comment">// Forgot to terminate chain with a catch!</span></span><br></pre></td></tr></table></figure>

<h4 id="错误解析"><a href="#错误解析" class="headerlink" title="错误解析"></a>错误解析</h4><ul>
<li><p>The first mistake is to not chain things together properly. This happens when we create a new promise but forget to return it. As a consequence, the chain is broken, or rather, we have two independent chains racing. This means <code>doFourthThing()</code> won’t wait for  <code>doSomethingElse()</code> or <code>doThirdThing()</code> to finish, and will run in parallel with them, likely unintended. Separate chains also have separate error handling, leading to uncaught errors.（这样会导致多个独立的<code>Promise</code>链并行运行，而且不同的链需要不同的错误处理，这样会导致一些我们没有预期的错误。）</p>
</li>
<li><p>The second mistake is to nest unnecessarily, enabling the first mistake. Nesting also limits the scope of inner error handlers, which—if unintended—can lead to uncaught errors. A variant of this is the <a href="https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it">promise constructor anti-pattern</a>, which combines nesting with redundant use of the promise constructor to wrap code that already uses promises.（第二个错误是不必要的嵌套，会诱发第一个问题，而且也有错误处理问题，一个变体就是<code>promise 构造函数反模式</code>，这个我会在下面给出示例）</p>
</li>
<li><p>The third mistake is forgetting to terminate chains with <code>catch</code>. Unterminated promise chains lead to uncaught promise rejections in most browsers.（第三个错误就是没有用catch来终止<code>promise</code>链）</p>
</li>
</ul>
<h4 id="Good-Code"><a href="#Good-Code" class="headerlink" title="Good Code"></a>Good Code</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">newResult</span> =&gt;</span> doThirdThing(newResult))</span><br><span class="line">.then(<span class="function">() =&gt;</span> doFourthThing())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br></pre></td></tr></table></figure>

<h4 id="反模式定义"><a href="#反模式定义" class="headerlink" title="反模式定义"></a>反模式定义</h4><p>下面来说说<code>Promise的构造函数反模式</code>,这是它的定义<code>which combines nesting with redundant use of the promise constructor to wrap code that already uses promises.</code></p>
<p>Example1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStuffDone</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">// using a promise constructor</span></span><br><span class="line">   	myPromiseFn(param)</span><br><span class="line">   	.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line"> 		resolve(val);</span><br><span class="line">   	&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    	reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Iview-admin中对反模式的使用"><a href="#Iview-admin中对反模式的使用" class="headerlink" title="Iview admin中对反模式的使用"></a>Iview admin中对反模式的使用</h4><p>另外再看一下<code>iview admin</code>中的应用（我只想说这个代码写的好迷呀🙄），违反了上面的注意事项，有两条不同的链，而且如果其中一个函数出错，那么肯定是没有得到处理，我觉得如果使用的化，最起码在两处加上<code>catch</code>语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">this</span>.handleLogin(&#123; userName, password &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getUserInfo().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">            name: <span class="built_in">this</span>.$config.homeName</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//改成链式</span></span><br><span class="line"> <span class="built_in">this</span>.handleLogin(&#123; userName, password &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUserInfo()</span><br><span class="line"> 		&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          	<span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">            name: <span class="built_in">this</span>.$config.homeName</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;login error&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><code>Vuex</code>中的代码（代码里加了注释）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleLogin (&#123; commit &#125;, &#123; userName, password &#125;) &#123;</span><br><span class="line">      userName = userName.trim()</span><br><span class="line">    	<span class="comment">//这里用了Promise的构造函数反模式</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        login(&#123;</span><br><span class="line">          userName,</span><br><span class="line">          password</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> data = res.data</span><br><span class="line">          commit(<span class="string">&#x27;setToken&#x27;</span>, data.token)</span><br><span class="line">          resolve()</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo (&#123; state, commit &#125;) &#123;</span><br><span class="line">     <span class="comment">//这里用了Promise的构造函数反模式，这里注意最后TA使用了Try Catch来解决不同链的错误处理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          getUserInfo(state.token).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> data = res.data</span><br><span class="line">         	....</span><br><span class="line">            commit(<span class="string">&#x27;setAccess&#x27;</span>, data.access)</span><br><span class="line">            resolve(data)</span><br><span class="line">          &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Quoting Esailija:</p>
<p>This is the most common anti-pattern. It is easy to fall into this when you don’t really understand promises and think of them as glorified event emitters or callback utility. Let’s recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</p>
<p>参考文章：</p>
<p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a><br> <a href="https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it">https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it</a><br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>三栏布局</title>
    <url>/2021/04/09/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;		</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">120px</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &gt; <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h4><p>Flex布局的缺点是兼容性问题，如果IE10+还是没有问题的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h4><p>流式布局的缺点是，不能使content内容优先渲染。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="comment">/*display: flow-root;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="comment">/*overflow: hidden;*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">220px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><p>绝对定位布局，简单实用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25070186">https://zhuanlan.zhihu.com/p/25070186</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>字节OpenDay总结</title>
    <url>/2021/04/12/%E5%AD%97%E8%8A%82OpenDay%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h4><p>​    大厂是在造轮子，而不是使用😶。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>首先他们介绍了南京字节的主要业务，数据平台。</li>
<li>进入Q&amp;A环节（主要聊了一些面试需要注意啥）。</li>
<li>吃吃工作餐。</li>
</ol>
<h4 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h4><ul>
<li>在简历中遵循STAR原则，结尾的Result中注意具体数据体现。</li>
<li>在面试时要从面试官的角度思考，要从一个点扩展到一个面。</li>
<li>如果在Github开源项目中有贡献最好。</li>
</ul>
<h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><ul>
<li>在学习中要注意脑图的使用，组成自己的技术结构</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>字节</tag>
      </tags>
  </entry>
  <entry>
    <title>回流与重绘</title>
    <url>/2021/04/18/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h3 id="浏览器渲染的关键路径"><a href="#浏览器渲染的关键路径" class="headerlink" title="浏览器渲染的关键路径"></a>浏览器渲染的关键路径</h3><p>The critical rendering path includes the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">Document Object Model </a>(DOM), <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model">CSS Object Model </a>(CSSOM), render tree and layout.</p>
<p><img src="/images/critical-rendering-path.jpg"></p>
<h3 id="关于渲染树"><a href="#关于渲染树" class="headerlink" title="关于渲染树"></a>关于渲染树</h3><p>The render tree only captures visible content. The head section (generally) doesn’t contain any visible information, and is therefore not included in the render tree. If there’s a display: none; set on an element, neither it, nor any of its descendants, are in the render tree.</p>
<p><img src="/images/render-tree-construction.jpg"></p>
<p>To construct the render tree, the browser roughly does the following:</p>
<ol>
<li>Starting at the root of the DOM tree, traverse each visible node.<ul>
<li>Some nodes are not visible (for example, script tags, meta tags, and so on), and are omitted since they are not reflected in the rendered output.</li>
<li>Some nodes are hidden via CSS and are also omitted from the render tree; for example, the span node—in the example above—is missing from the render tree because we have an explicit rule that sets the “display: none” property on it.</li>
</ul>
</li>
<li>For each visible node, find the appropriate matching CSSOM rules and apply them.</li>
<li>Emit visible nodes with content and their computed styles.</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">note that visibility: hidden is different from display: none. The former makes the element invisible, but the element still occupies space in the layout (that is, it&#x27;s rendered as an empty box), whereas the latter (display: none) removes the element entirely from the render tree such that the element is invisible and is not part of the layout.</span><br></pre></td></tr></table></figure>

<h3 id="布局与绘制定义"><a href="#布局与绘制定义" class="headerlink" title="布局与绘制定义"></a>布局与绘制定义</h3><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>Once the render tree is built, layout becomes possible. Layout is dependent on the size of screen. The layout step determines where and how the elements are positioned on the page, determining the width and height of each element, and where they are in relation to each other.</p>
<h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>The last step is painting the pixels to the screen. Once the render tree is created and layout occurs, the pixels can be painted to the screen. Onload, the entire screen is painted. After that, only impacted areas of the screen will be repainted, as browsers are optimized to repaint the minimum area required. Paint time depends on what kind of updates are being applied to the render tree.</p>
<h3 id="布局触发条件"><a href="#布局触发条件" class="headerlink" title="布局触发条件"></a>布局触发条件</h3><p> Any time the render tree is modified, such as by added nodes, altered content, or updated box model styles on a node, layout occurs.</p>
<h3 id="关于绘制"><a href="#关于绘制" class="headerlink" title="关于绘制"></a>关于绘制</h3><p>While painting is a very fast process, and therefore likely not the most impactful place to focus on in improving performance。</p>
<h3 id="浏览器优化机制"><a href="#浏览器优化机制" class="headerlink" title="浏览器优化机制"></a>浏览器优化机制</h3><p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect</li>
<li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">https://gist.github.com/pauli…</a>点击预览</li>
</ul>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p>
<h3 id="如何减少回流与重绘带来的性能损失"><a href="#如何减少回流与重绘带来的性能损失" class="headerlink" title="如何减少回流与重绘带来的性能损失"></a>如何减少回流与重绘带来的性能损失</h3><ul>
<li>先将元素设为<code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li>
<li>position属性为<code>absolute</code>或<code>fixed</code>的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li>
</ul>
<p>参考链接：</p>
<p><a href="https://segmentfault.com/a/1190000017329980">https://segmentfault.com/a/1190000017329980</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path">https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path</a></p>
<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work">https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>回流与重绘</tag>
      </tags>
  </entry>
</search>
